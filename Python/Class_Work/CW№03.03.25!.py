#Завдання №1
"""
Список у Python — це впорядкований набір елементів, який можна змінювати.
Списки створюються за допомогою квадратних дужок []
і можуть містити будь-які типи даних,
наприклад, цілі числа, числа з плаваючою комою, рядки, булеві значення.
list = [1, 2, 3.6, "hello", True]
"""

#Завдання №2
"""
Словник — це неупорядкований набір пар ключ-значення, який також можна змінювати. 
Словники створюються за допомогою фігурних дужок {}. 
dict = {"name": "John", "age": 30}
Словник складається:
item = key: value
Ключ(key)       - унікальний ідентифікатор, що вказує на значення
Значення(value) - значення ключа
Пара(item)      - один елемент словнику (ключ-значення)
"""


#Завдання №3
"""
Тип даних, який позначається дужками {}, називається словником. 
Словники використовуються для зберігання даних у вигляді пар ключ-значення.
"""


#Завдання №4
"""
Iterable — це об'єкт, який можна ітерувати, тобто пройти через нього послідовно. 
Прикладами ітерабельних об'єктів є  
списки (list), кортежі (tuple), рядки (str), словники (dict), множини (set). 
Функції типу map(), max(), min() можуть приймати ітерабельні об'єкти як аргументи, 
обробляючи їх елементи послідовно.
Iterable — це об'єкт, який можна "перебирати" (наприклад, у циклі for), 
і саме це дозволяє функціям обробляти його вміст.
"""


#Завдання №5
"""
5.	Ви вирішили написати перетворювач коду на Python в код на Java. 
Так як на Java прийнятий стандарт найменування CamelCase, 
то ви вирішили навчитися перетворювати імена з underscore в цей формат. 
Стиль underscore характеризується тим, що слова в імені пишуться 
маленькими літерами і розділяються між собою символом підкреслення _. 
Стиль CamelCase означає, що кожне слово пишеться з великої літери 
і роздільників між словами немає. Отже, вводиться один рядок, 
що містить ім’я, записане в форматі underscore. 
Програма виводить рядок, що містить ім’я в форматі CamelCase.
________________________________________
Вхідні дані:
my_class
c
Вихідні дані:
MyClass
C
"""
#variant1
text = input('Введіть слова у форматі underscore: ')
words = text.split("_")
result = "".join([word.capitalize() for word in words])
print(result)

#variant2
underscore = 'my_first_var'
for word in underscore.split('_'):
    camel += word.capitalize()
print(camel)
#variant3
camel = ''.join(word.capitalize() for word in underscore.split('_'))
print(camel)

#Завдання №557 (Замість 6,7)
"""
У вхідному рядку записана послідовність чисел через пропуск. 
Для кожного числа потрібно вивести слово YES (в окремому рядку), 
якщо це число раніше зустрічалося в послідовності, 
або NO, якщо не зустрічалося.
Вхідні дані: 4 6 1 8 4 9 0 1
Вихідні дані:
NO  
NO  
NO  
NO  
YES  
NO  
NO  
YES 
"""
numbers = input('Введіть цифри через пробіл: ').split()
dic_numbers = {}
for num in numbers:
    if num in dic_numbers:
        print("YES")
    else:
        print("NO")
        dic_numbers[num] = True
memory = set()

#variant
numbers = []
for el in numbers:
    if el in memory:
        print('NO')
        memory.add(el)
    else:
        print('YES')


for index in range(len(numbers)):
    if numbers[index] in numbers[:index]:
        print('NO')
    else:
        print('YES')


#Завдання№8
"""
Напишіть програму для пошуку загальних елементів з двох введених рядків слів.
________________________________________
Вхідні дані:
Red Green Orange White
Black Green White Pink
Вихідні дані:
White Green
"""
#variant1
text1 = input("Введіть слова №1, розділених пробілами: ").split()
text2 = input("Введіть слова №2, розділених пробілами: ").split()
print(" ".join(set(text1).intersection(set(text2))))

#variant2
word_1 = input('Введіть слова з пробілом: ').split()
word_2 = input('Введіть слова з пробілом: ').split()

print(' '.join(set(word_1).intersection(word_2)))

#Завдання№9
"""
Двоє друзів вирішили здійснити влітку сходження в гори Карпати. 
Кожен з них зібрав свій рюкзак речей. Перевірте, які речі присутні 
в обох рюкзаках друзів, які є лише в першому рюкзаку, але не має в другому і, 
навпаки, є в другому і відсутні в першому. Дано два словники, 
у яких ключами є назви речей, а значеннями - кількості речей. 
Надрукуйте назви речей і їх кількості, які пристутні в обох рюкзаках друзів, 
лише в першому рюкзаку і лише в другому рюкзаку.
"""
#Variant#1
friend_1 = {
    'шкарпетки': 3,
    'намет': 1,
    'сокира': 2,
    'кастрюля': 1,
    'вода': 5,
    'їжа': 3
}

friend_2 = {
    'намет': 1,
    'їжа': 2,
    'вода': 2,
    'ніж': 1,
    'бінокль': 2
}

all_items = []
for item in friend_1:
    if item in friend_2:
        all_items.append(item)

only_friend_1 = []
for item in friend_1:
    if item not in friend_2:
        only_friend_1.append(item)

only_friend_2 = []
for item in friend_2:
    if item not in friend_1:
        only_friend_2.append(item)

print("У обох рюкзаках:")
for item in all_items:
    print(f"{item}: {min(friend_1[item], friend_2[item])}")

print("\nТільки у першого друга:")
for item in only_friend_1:
    print(f"{item}: {friend_1[item]}")

print("\nТільки у другого друга:")
for item in only_friend_2:
    print(f"{item}: {friend_2[item]}")

#Variant#2
friend_1 = {
    'шкарпетки': 3,
    'намет': 1,
    'сокира': 2,
    'кастрюля': 1,
    'вода': 5,
    'їжа': 3
}

friend_2 = {
    'намет': 1,
    'їжа': 2,
    'вода': 2,
    'ніж': 1,
    'бінокль': 2
}
all_items = set(friend_1) & set(friend_2)
only_friend1 = set(friend_1) - set(friend_2)
only_friend2 = set(friend_2) - set(friend_1)
unique_items = set(friend_1) ^ set(friend_2)

print("У обох рюкзаках:")
for item in all_items:
    print(f"{item}: {min(friend_1[item], friend_2[item])}")

print("\nТільки у першого друга:")
for item in only_friend1:
    print(f"{item}: {friend_1[item]}")

print("\nТільки у другого друга:")
for item in only_friend2:
    print(f"{item}: {friend_2[item]}")

print("\nРечі, які є лише в одного з друзів, але не в обох:")
for item in unique_items:
    print(item)

#Variant#3
friend_1 = {
    'шкарпетки': 3,
    'намет': 1,
    'сокира': 2,
    'кастрюля': 1,
    'вода': 5,
    'їжа': 3
}

friend_2 = {
    'намет': 1,
    'їжа': 2,
    'вода': 2,
    'ніж': 1,
    'бінокль': 2

in_both = set(friend_1).intersection(friend_2) #ітерує лише ключі
friend_1_only = set(friend_1).difference(friend_2)
friend_2_only = set(friend_2).difference(friend_1)
print('Спільні речі: ')
for key in_both:
    print(f'{key}: {friend_1[key] + friend2[key]}')

 print('Тільки у першого: ')
 for key in friend_1_only:
     print(f'{key}: ')


#Завдання№10
"""
Дано список цілих чисел. Потрібно стиснути його, перемістивши всі ненульові елементи 
в ліву частину списку, не змінюючи їх порядок, а всі нулі - в праву частину. 
Порядок ненульових елементів змінювати не можна, додатковий список використовувати не можна, 
завдання потрібно виконати за один прохід по списку. Роздрукуйте отриманий список.
________________________________________
Вхідні дані:
6 0 3 0 5 0 0 4
Вихідні дані:
6 3 5 4 0 0 0 0
"""

numbers = input("Введіть список чисел через пробіл: ").split()
nums = [int(el) for el in numbers]
count = 0

for i in range(len(nums)):
    if nums[i] != 0:
        nums[count], nums[i] = nums[i], nums[count]
        count += 1
print(*nums)

numbers = [6, 0, 3, 0, 5, 0, 0, 4]
for el in numbers:
    if el == 0:
        numbers.remove(0)
        numbers.append(0)
print(numbers)


#Завдання№11
"""
11.	У римській системі числення для позначення чисел використовуються наступні символи 
(праворуч записані числа, яким вони відповідають в десятковій системі числення):
I = 1
V = 5
X = 10
L = 50
C = 100
D = 500
M = 1000
Будемо використовувати варіант, в якому числа 4, 9, 40, 90, 400 і 900 записуються 
як віднімання від більшого числа меншого: IV, IX, XL, XC, CD і CM, відповідно. 
Напишіть програму, яка за введеним натуральним числом n (0 < n < 4000) виведе рядок, 
що містить число, закодоване в римській системі числення.
________________________________________
Вхідні дані:
2022
11
1
Вихідні дані:
MMXXII
XI
I
"""
number = int(input("Введіть ціле число від 1 до 3999: "))
if number <= 0 or number >= 4000:
    print("Число має бути від 1 до 3999!")
else:
    dic = {
        1000: "M", 900: "CM", 500: "D", 400: "CD",
        100: "C", 90: "XC", 50: "L", 40: "XL",
        10: "X", 9: "IX", 5: "V", 4: "IV", 1: "I"
    }
    result = ""
    for value, symbol in dic.items():
        while number >= value:
            result += symbol
            number -= value
    print(result)

dic = {
    1000: "M",
    900: "CM",
    500: "D",
    400: "CD",
    100: "C",
    90: "XC",
    50: "L",
    40: "XL",
    10: "X",
    9: "IX",
    5: "V",
    4: "IV",
    1: "I"
}
dic = dict(sorted(dic.items(), key=lambda el: el[0], reverse=True))
number = int(input('Введіть число: '))
roman_result = ''
#var1
for n, roman in dic.items():
    while n <= number:
        number -= n
        roman_result += roman
print(roman_result)
#var2
while number > 0:
    for n, roman in dic.items():
        if n <= number:
            number -= n
            roman_result += roman
            break
print(roman_result)

#Завдання№12
"""
Створимо карту кімнати 5x5, посередині якої знаходиться робот 
(у вигляді двомірного списку). Робот позначається рядком “R”,  
порожній простір: “*”.
Приклад кімнати (можна скопіювати собі): 
room = [
    ['*', '*', '*', '*', '*',], 
    ['*', '*', '*', '*', '*',], 
    ['*', '*', 'R', '*', '*',], 
    ['*', '*', '*', '*', '*',], 
    ['*', '*', '*', '*', '*',]
]
Користувач вводить команди, поки не введе «0». 
Кожна команда вводиться у форматі «<Напрям> <Кількість клітинок>». 
Кожна команда рухає робота на вказану кількість клітинок у вказаний напрям. 
Наприклад: “RIGHT 2” – означає на 2 клітинки вправо. 
Кількість команд не обмежена, поки не буде введено 0. 
Якщо робот упирається в стіну, він просто встає не місці, 
поки не буде обрано інший напрям. Обробіть весь рух робота, 
і після того, як буде введено «0», надрукуйте список, 
де буде зафіксовано останнє положення робота.
"""
#На даний етап навчання складно для мене.
#Не зовсім розумію просторове переміщення.

#var1
text = ['сонце', 'Дніпро', 'овочі', 'щука', 'Каліфорнія']
for el in text:
    if el[0].islower():
        text.remove(el)
print(text)

#var2
text = ['сонце', 'Дніпро', 'овочі', 'щука', 'Каліфорнія']
for el in text.copy:
    if el[0].islower():
        text.remove(el)
print(text)