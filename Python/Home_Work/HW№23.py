import time
import random as rd

# --- Декоратор для вимірювання часу (твій код) ---
def time_decorator(function):
    def wrapper(*args, **kwargs):
        # Запам'ятовуємо час перед початком виконання функції
        start = time.time()
        # Викликаємо саму функцію
        result = function(*args, **kwargs)
        # Запам'ятовуємо час після завершення функції
        end = time.time()
        # Розраховуємо та виводимо тривалість виконання
        print(f'Час виконання {function.__name__}: {end - start:.6f} сек') # :.6f для 6 знаків після коми
        return result
    return wrapper

#========================== Алгоритм пірамідального сортування (Heapsort) =========================

# Допоміжна функція: перетворює піддерево з коренем i на max-heap
# n - розмір купи
# i - індекс кореня піддерева
def heapify(arr, n, i):
    largest = i  # Вважаємо корінь найбільшим
    left_child = 2 * i + 1     # індекс лівого нащадка
    right_child = 2 * i + 2    # індекс правого нащадка

    # Чи існує лівий нащадок і чи він більший за поточний найбільший?
    if left_child < n and arr[left_child] > arr[largest]:
        largest = left_child

    # Чи існує правий нащадок і чи він більший за поточний найбільший?
    if right_child < n and arr[right_child] > arr[largest]:
        largest = right_child

    # Якщо найбільший елемент - не корінь (тобто знайшли більшого нащадка)
    if largest != i:
        # Міняємо місцями корінь з найбільшим нащадком
        arr[i], arr[largest] = arr[largest], arr[i]
        # Рекурсивно викликаємо heapify для піддерева, куди "опустився"
        # початковий корінь (тепер це індекс largest),
        # щоб відновити властивість max-heap там
        heapify(arr, n, largest)

# Основна функція Heapsort з декоратором для вимірювання часу
@time_decorator
def heap_sort(arr: list):
    n = len(arr) # Розмір списку

    # 1. Побудова max-heap (перегрупування масиву).
    # Починаємо з останнього батьківського вузла (n // 2 - 1)
    # і рухаємось вгору до кореня (0).
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i) # Перетворюємо кожне піддерево на max-heap

    # 2. Видобування елементів з купи (один за одним).
    # Йдемо від останнього елемента (n-1) до другого (1).
    for i in range(n - 1, 0, -1):
        # Міняємо місцями поточний корінь (найбільший елемент купи)
        # з останнім елементом *поточної* купи (arr[i]).
        # Тепер найбільший елемент знаходиться на своєму фінальному місці.
        arr[i], arr[0] = arr[0], arr[i]

        # Зменшуємо розмір купи на 1 (розглядаємо частину від 0 до i-1)
        # і викликаємо heapify для кореня (0), щоб відновити
        # властивість max-heap для зменшеної купи.
        heapify(arr, i, 0) # Розмір купи тепер 'i'

# --- Приклад використання та порівняння ---

# Створюємо список випадкових чисел
list_size = 1000_000 # Можна змінити розмір для тестування
my_list = [rd.randint(-500, 1000) for _ in range(list_size)]
print(f"Створено список з {list_size} елементів.")
#print(f"Початковий список (перші 20): {my_list[:20]}") # Показати частину, якщо потрібно

# ВАЖЛИВО: Робимо копії списку для кожного сортування!
# Heapsort змінює список "на місці", тому нам потрібна копія
# для порівняння з `sorted()`, яка працює з оригінальними даними.
list_for_heap = my_list.copy()
list_for_sorted = my_list.copy()

print("\n--- Запуск Heapsort ---")
# Викликаємо нашу функцію heapsort. Декоратор автоматично виведе час.
heap_sort(list_for_heap)
#print(f"Список після Heapsort (перші 20): {list_for_heap[:20]}") # Показати результат

print("\n--- Запуск вбудованого sorted() ---")
# Вимірюємо час для вбудованої функції sorted() вручну
start_py = time.time()
sorted_list_py = sorted(list_for_sorted) # sorted() повертає НОВИЙ відсортований список
end_py = time.time()
print(f'Час виконання sorted(): {end_py - start_py:.6f} сек')
#print(f"Список після sorted() (перші 20): {sorted_list_py[:20]}") # Показати результат

# Перевірка, чи результати однакові (необов'язково, але корисно)
if list_for_heap == sorted_list_py:
    print("\nРезультати Heapsort та sorted() збігаються.")
else:
    print("\nУВАГА! Результати Heapsort та sorted() НЕ збігаються.")