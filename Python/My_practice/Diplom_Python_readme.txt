Детальні пояснення до коду:
Імпорти та Конфігурація:
import json: Для роботи з JSON-файлами.
from datetime import datetime: Для отримання поточної дати та часу (використовується для відмітки часу додавання та редагування записів).
import locale: Для налаштування відображення чисел і валют відповідно до українських стандартів. Це робить вивід зрозумілішим.
import os: Додано для створення папки files, якщо вона не існує, перед спробою зберегти туди файл.
DATA_DIR, DATABASE_FILE: Визначено константи для папки та імені файлу бази даних.
MONTHS, EMPLOYEE_LEVELS: Списки допустимих значень, що допомагають валідувати ввід користувача.
validate_month_format(month_str): Функція для перевірки, чи коректно введено місяць та рік ("Місяць Рік").
month_to_tuple(month_year_str): Допоміжна функція для перетворення рядка "Місяць Рік" у кортеж (рік, номер_місяця). Це потрібно для правильного хронологічного сортування записів.
Клас SalarySettings:
__init__(...): Конструктор. Ініціалізує словники base_amounts, coefficients, task_costs та значення standard_monthly_hours, default_rates. Якщо при створенні об'єкта передаються дані (наприклад, завантажені з файлу), використовуються вони, інакше - значення за замовчуванням. Додано перевірку, що для всіх стандартних рівнів є налаштування.
to_dict(): Метод, який перетворює об'єкт SalarySettings на простий словник. Це необхідно для збереження даних у форматі JSON.
from_dict(cls, data): Класовий метод (@classmethod), який створює об'єкт SalarySettings зі словника, завантаженого з JSON. Використовується cls(...) замість SalarySettings(...), щоб метод працював правильно, якщо клас буде успадкований. Використовує .get() для безпечного доступу до ключів, щоб уникнути помилок, якщо файл даних старіший і не містить деяких полів.
update_base_amount, update_coefficient, update_task_cost, delete_task_cost, update_standard_hours, update_default_rates: Методи для зміни налаштувань. Вони включають базову перевірку вводу (наприклад, чи існує рівень, чи число більше нуля) і виводять повідомлення про результат.
Клас MonthlySalaryRecord:
__init__(...): Конструктор. Ініціалізує всі атрибути одного запису: ID, ім'я працівника, місяць/рік, рівень, години, вартість завдань, курси валют, розраховану зарплату, дату додавання та історію змін. Включена перевірка формату місяця.
to_dict(): Перетворює об'єкт запису на словник для JSON.
from_dict(cls, data): Класовий метод для створення об'єкта запису зі словника JSON. Також використовує .get() для безпеки.
add_history_entry(changes): Метод додавання запису до історії змін цього об'єкта. Зберігає час зміни та словник з описанням, що саме змінилось (старе і нове значення).
Клас SalaryManager:
__init__(self, database_file): Конструктор головного менеджера. Приймає ім'я файлу бази даних. Створює порожні списки для записів (monthly_records) та ініціалізує об'єкт налаштувань (settings). Одразу викликає приватний метод _load_data() для завантаження даних.
_load_data(): Приватний метод (починається з _, що означає, що його не слід викликати напряму ззовні класу). Читає JSON-файл. Якщо файл існує і коректний, він парсить дані, створює об'єкт SalarySettings та список об'єктів MonthlySalaryRecord. Обробляє помилки FileNotFoundError (файл не знайдено) та json.JSONDecodeError (файл порожній або пошкоджений), і в цих випадках створює нову, порожню структуру даних з налаштуваннями за замовчуванням і зберігає її. Додано створення папки files.
_save_data(): Приватний метод. Перетворює об'єкт settings та список об'єктів monthly_records назад у структуру словників і списків, придатну для JSON, і записує її у файл. Використано indent=4 для гарного форматування файлу та ensure_ascii=False для коректного збереження кирилиці.
get_next_record_id(): Простий метод для генерації унікального ID для нового запису, просто знаходячи максимальний ID у списку та додаючи 1.
calculate_salary(level, actual_hours, tasks_completed_value): Основний метод розрахунку зарплати. Використовує формулу, засновану на твоєму завданні:
Бере базову ставку (base_amount) та коефіцієнт (coefficient) для заданого level з self.settings.
Бере стандартну кількість годин (standard_hours) з self.settings.
Розраховує "вартість години" з базової ставки: hourly_base_rate = base_amount / standard_hours. Додана перевірка standard_hours > 0.
Розраховує базову частину зарплати за фактично відпрацьовані години: base_salary_part = hourly_base_rate * actual_hours.
Бере загальну вартість виконаних завдань за місяць (tasks_completed_value) як додаткову частину (additional_salary_part).
Загальна сума до застосування коефіцієнта: total_uah_before_coeff = base_salary_part + additional_salary_part.
Кінцева зарплата: final_salary_uah = total_uah_before_coeff * coefficient. Коефіцієнт застосовується до обох частин зарплати разом, як можна інтерпретувати з умови "To distinguish the quality... they must have a coefficient (the same as the main one)".
convert_currency, format_salary: Перенесені з твого початкового коду, адаптовані для роботи з об'єктом менеджера (self.settings.default_rates).
add_salary_record(), delete_salary_record(), edit_salary_record(): Методи для взаємодії з користувачем, збору вводу, валідації, створення/оновлення об'єктів MonthlySalaryRecord та збереження даних через _save_data(). У edit_salary_record реалізовано логування змін.
find_record_by_id(): Допоміжний метод для пошуку запису в списку за його ID.
display_record_details(): Допоміжний метод для акуратного виведення деталей одного запису, включаючи історію змін.
print_all_salary_data(), print_salary_by_month(), calculate_total_salary_by_year(), print_salary_by_year(), print_average_salary_by_year(): Методи для виведення даних у різних форматах, фільтрації та сортування.
manage_settings(), print_settings(), edit_base_amounts(), edit_coefficients(), edit_task_costs(), edit_standard_hours(), edit_default_rates(): Набір методів для керування глобальними налаштуваннями через окреме підменю. Вони взаємодіють з об'єктом self.settings та викликають _save_data() після внесення змін.
main() функція:
Створює головний об'єкт SalaryManager.
Реалізує головне меню програми, приймаючи ввід користувача та викликаючи відповідні методи об'єкта manager.
Як запустити програму:
Збережи код у файл з розширенням .py (наприклад, salary_app.py).
Відкрий термінал або командний рядок.
Перейди до папки, де збережено файл.
Запусти програму командою python salary_app.py.
Програма створить папку files та файл salary_data.json поруч з файлом .py, якщо вони не існують.
Переваги цього ООП підходу порівняно з процедурним кодом:
Структура: Код поділений на логічні блоки (класи), кожен відповідає за свою частину функціональності (налаштування, окремий запис, загальне керування). Це робить код більш організованим.
Інкапсуляція: Дані (атрибути класу) та функції, які працюють з цими даними (методи класу), зібрані разом. Наприклад, MonthlySalaryRecord знає, як зберегти свої дані у словник (to_dict), але розрахунок зарплати (calculate_salary) знаходиться в SalaryManager, тому що для розрахунку потрібні дані з SalarySettings.
Повторне використання: Класи можна використовувати як шаблони для створення багатьох об'єктів (наприклад, багато MonthlySalaryRecord). Хоча в цьому прикладі це не так очевидно, як у складніших системах.
Легше розширення: Якщо з'являться нові вимоги (наприклад, додавання премій, інших типів завдань, управління працівниками як окремою сутністю), їх легше інтегрувати, додаючи нові класи або розширюючи існуючі, не переписуючи всю програму з нуля.
Читабельність: Код стає зрозумілішим, тому що ти бачиш, які дані належать до яких операцій (наприклад, manager.add_salary_record() чітко говорить, що відбувається додавання запису через об'єкт менеджера).
Це досить великий крок від процедурного стилю, але він необхідний для створення більш складних та підтримуваних програм. Не соромся ставити запитання, якщо щось незрозуміло! Успіхів у навчанні!